/* eslint-disable @typescript-eslint/no-unused-vars */
import { ResourceCache, PagedResourceCache } from '../../../../src/sdk/app/resource-cache';
import { RequestError } from '../../../../src/sdk/app/rpc';
import { ErrorCode } from '../../../../src/sdk/types/Rpc';

/**
 * @warning
 * Test code generated by AI.
 */

describe('ResourceCache', () => {
    let cache: ResourceCache;

    beforeEach(() => {
        cache = new ResourceCache();
    });

    describe('getAsync', () => {
        it('should call getter and cache result on success', async () => {
            let callCount = 0;
            const mockGetter = async (arg1: string, arg2: string) => {
                callCount++;
                expect(arg1).toBe('arg1');
                expect(arg2).toBe('arg2');
                return 'test-result';
            };
            const resourceKey = ['user', '123'];

            const result = await cache.getAsync(mockGetter, resourceKey, 'arg1', 'arg2');

            expect(result).toBe('test-result');
            expect(callCount).toBe(1);
        });

        it('should return cached value when getter throws NOT_MODIFIED error', async () => {
            let callCount = 0;
            const mockGetter = async () => {
                callCount++;
                if (callCount === 1) {
                    return 'cached-value';
                } else {
                    throw new RequestError(ErrorCode.NOT_MODIFIED, 'Not modified');
                }
            };
            const resourceKey = ['user', '123'];

            // First call to populate cache
            const firstResult = await cache.getAsync(mockGetter, resourceKey);
            expect(firstResult).toBe('cached-value');

            // Second call should return cached value
            const secondResult = await cache.getAsync(mockGetter, resourceKey);
            expect(secondResult).toBe('cached-value');
            expect(callCount).toBe(2);
        });

        it('should throw error when getter throws non-NOT_MODIFIED error', async () => {
            const mockGetter = async () => {
                throw new RequestError(ErrorCode.BAD_REQUEST, 'Bad request');
            };
            const resourceKey = ['user', '123'];

            await expect(cache.getAsync(mockGetter, resourceKey)).rejects.toThrow('Bad request');
        });

        it('should handle different resource keys separately', async () => {
            const mockGetter1 = async () => 'result1';
            const mockGetter2 = async () => 'result2';
            const resourceKey1 = ['user', '123'];
            const resourceKey2 = ['user', '456'];

            const result1 = await cache.getAsync(mockGetter1, resourceKey1);
            const result2 = await cache.getAsync(mockGetter2, resourceKey2);

            expect(result1).toBe('result1');
            expect(result2).toBe('result2');
        });
    });

    describe('update', () => {
        it('should update existing cached value', async () => {
            let callCount = 0;
            const mockGetter = async (): Promise<{ count: number }> => {
                callCount++;
                if (callCount === 1) {
                    return { count: 1 };
                } else {
                    throw new RequestError(ErrorCode.NOT_MODIFIED, 'Not modified');
                }
            };
            const resourceKey = ['counter', '1'];

            // First populate cache
            await cache.getAsync(mockGetter, resourceKey);

            // Update the cached value
            cache.update((value: { count: number } | undefined) => ({ count: (value?.count || 0) + 1 }), resourceKey);

            // Verify cache hit with updated value
            const result = await cache.getAsync(mockGetter, resourceKey);

            expect(result).toEqual({ count: 2 });
        });
    });
});

describe('PagedResourceCache', () => {
    let cache: PagedResourceCache<string>;

    beforeEach(() => {
        cache = new PagedResourceCache<string>();
    });

    describe('getAsync', () => {
        it('should call getter and cache results on success', async () => {
            let callCount = 0;
            const mockGetter = async (offset: number, quantity: number) => {
                callCount++;
                expect(offset).toBe(0);
                expect(quantity).toBe(3);
                return ['item1', 'item2', 'item3'];
            };

            const result = await cache.getAsync(mockGetter, 0, 3);

            expect(result).toEqual(['item1', 'item2', 'item3']);
            expect(callCount).toBe(1);
        });

        it('should return cached items when getter throws NOT_MODIFIED error', async () => {
            let callCount = 0;
            const mockGetter = async (offset: number, quantity: number) => {
                callCount++;
                if (callCount === 1) {
                    return ['cached1', 'cached2'];
                } else {
                    throw new RequestError(ErrorCode.NOT_MODIFIED, 'Not modified');
                }
            };

            // First call to populate cache
            const firstResult = await cache.getAsync(mockGetter, 0, 2);
            expect(firstResult).toEqual(['cached1', 'cached2']);

            // Second call should return cached values
            const secondResult = await cache.getAsync(mockGetter, 0, 2);
            expect(secondResult).toEqual(['cached1', 'cached2']);
            expect(callCount).toBe(2);
        });

        it('should clear cache when fetching from offset 0', async () => {
            let callCount = 0;
            const mockGetter = async (offset: number, quantity: number) => {
                callCount++;
                if (callCount === 1) {
                    // First call: populate cache at offset 5
                    return ['item5', 'item6'];
                } else if (callCount === 2) {
                    // Second call: fetch from offset 0 should clear cache
                    return ['newItem0', 'newItem1'];
                } else {
                    throw new RequestError(ErrorCode.NOT_MODIFIED, 'Not modified');
                }
            };

            // First call to populate cache at offset 5
            const firstResult = await cache.getAsync(mockGetter, 5, 2);
            expect(firstResult).toEqual(['item5', 'item6']);

            // Second call from offset 0 should clear existing cache
            const secondResult = await cache.getAsync(mockGetter, 0, 2);
            expect(secondResult).toEqual(['newItem0', 'newItem1']);

            // Third call should use new cache
            const thirdResult = await cache.getAsync(mockGetter, 0, 2);
            expect(thirdResult).toEqual(['newItem0', 'newItem1']);
            expect(callCount).toBe(3);
        });

        it('should mark missing items as null when fewer items returned', async () => {
            let callCount = 0;
            const mockGetter = async (offset: number, quantity: number) => {
                callCount++;
                if (callCount === 1) {
                    // Return only 2 items when 4 requested - items 2-3 should be marked as null
                    return ['item0', 'item1'];
                } else {
                    throw new RequestError(ErrorCode.NOT_MODIFIED, 'Not modified');
                }
            };

            // Request 4 items but only get 2
            const firstResult = await cache.getAsync(mockGetter, 0, 4);
            expect(firstResult).toEqual(['item0', 'item1']);

            // Second call should return cached items (nulls are filtered out)
            const secondResult = await cache.getAsync(mockGetter, 0, 4);
            expect(secondResult).toEqual(['item0', 'item1']);
            expect(callCount).toBe(2);
        });

        it('should fetch missing segments when getter throws NOT_MODIFIED error', async () => {
            let callCount = 0;
            const callsReceived: Array<[number, number]> = [];
            const mockGetter = async (offset: number, quantity: number) => {
                callCount++;
                callsReceived.push([offset, quantity]);
                
                if (callCount === 1) {
                    // Initial fetch: populate positions 0-1
                    return ['item0', 'item1'];
                } else if (callCount === 2) {
                    // NOT_MODIFIED error on requesting 0-2 (cache only has 0-1)
                    throw new RequestError(ErrorCode.NOT_MODIFIED, 'Not modified');
                }
                return [];
            };

            // First call to populate partial cache (positions 0-1)
            await cache.getAsync(mockGetter, 0, 2);

            // Request same range - should return cached items only since missing segment at end is not fetched
            const result = await cache.getAsync(mockGetter, 0, 2);

            expect(result).toEqual(['item0', 'item1']);
            expect(callCount).toBe(2);
            expect(callsReceived[0]).toEqual([0, 2]); // Initial fetch
            expect(callsReceived[1]).toEqual([0, 2]); // NOT_MODIFIED request
        });

        it('should fetch missing segments in the middle when getter throws NOT_MODIFIED error', async () => {
            let callCount = 0;
            const callsReceived: Array<[number, number]> = [];
            const mockGetter = async (offset: number, quantity: number) => {
                callCount++;
                callsReceived.push([offset, quantity]);
                
                if (callCount === 1) {
                    // Initial fetch: populate positions 0-1
                    return ['item0', 'item1'];
                } else if (callCount === 2) {
                    // Manually populate position 3 (create gap at position 2)
                    return ['item3'];
                } else if (callCount === 3) {
                    // NOT_MODIFIED error on requesting 0-4 (cache has gap at 2)
                    throw new RequestError(ErrorCode.NOT_MODIFIED, 'Not modified');
                } else if (callCount === 4) {
                    // Fetch missing segment at position 2 (quantity 1)
                    return ['item2'];
                }
                return [];
            };

            // First call to populate positions 0-1
            await cache.getAsync(mockGetter, 0, 2);
            
            // Second call to populate position 3 (creates gap at 2)
            await cache.getAsync(mockGetter, 3, 1);

            // Request full range - should detect missing item at position 2
            const result = await cache.getAsync(mockGetter, 0, 4);

            expect(result).toEqual(['item0', 'item1', 'item2', 'item3']);
            expect(callCount).toBe(4);
            expect(callsReceived[3]).toEqual([2, 1]); // Missing segment fetch
        });

        it('should handle CONFLICT error by clearing cache', async () => {
            let callCount = 0;
            const mockGetter = async (offset: number, quantity: number) => {
                callCount++;
                if (callCount === 1) {
                    return ['item0', 'item1'];
                } else if (callCount === 2) {
                    // CONFLICT error should clear cache
                    throw new RequestError(ErrorCode.CONFLICT, 'List changed');
                } else {
                    return ['newItem0', 'newItem1'];
                }
            };

            // Populate cache
            await cache.getAsync(mockGetter, 0, 2);

            // Request with CONFLICT error should clear cache and rethrow
            try {
                await cache.getAsync(mockGetter, 5, 2);
                fail('Should have thrown CONFLICT error');
            } catch (error) {
                expect(error).toBeInstanceOf(RequestError);
                expect((error as RequestError).code).toBe(ErrorCode.CONFLICT);
            }

            // Cache should be cleared, so next request should work normally
            const result = await cache.getAsync(mockGetter, 0, 2);
            expect(result).toEqual(['newItem0', 'newItem1']);
            expect(callCount).toBe(3);
        });
    });

    describe('unshift', () => {
        it('should add item to the beginning of cache', async () => {
            let callCount = 0;
            const mockGetter = async (offset: number, quantity: number) => {
                callCount++;
                if (callCount === 1) {
                    return ['item1', 'item2'];
                } else {
                    throw new RequestError(ErrorCode.NOT_MODIFIED, 'Not modified');
                }
            };

            // Populate cache
            await cache.getAsync(mockGetter, 0, 2);

            // Add item to beginning
            cache.unshift('item0');

            // Fetch should return the unshifted item first
            const result = await cache.getAsync(mockGetter, 0, 3);

            expect(result).toEqual(['item0', 'item1', 'item2']);
        });
    });

    describe('delete', () => {
        it('should delete items matching the filter', async () => {
            const mockGetter = async (offset: number, quantity: number) => {
                return ['apple', 'banana', 'cherry', 'apricot'];
            };

            // Populate cache
            const initialResult = await cache.getAsync(mockGetter, 0, 4);
            expect(initialResult).toEqual(['apple', 'banana', 'cherry', 'apricot']);

            // Delete items starting with 'a' - should remove them completely (no position preservation)
            cache.delete((item: string) => item.startsWith('a'));

            // After delete, array becomes shorter: ['banana', 'cherry']
            // Since cache is now shorter, requesting offset 0 will invalidate and refetch
            const mockGetterAfterDelete = async (offset: number, quantity: number) => {
                if (offset === 0 && quantity === 4) {
                    // Cache invalidated on offset 0, should be called again
                    return ['banana', 'cherry', 'date', 'elderberry'];
                }
                return [];
            };

            // Should get fresh data since cache was invalidated
            const result = await cache.getAsync(mockGetterAfterDelete, 0, 4);

            expect(result).toEqual(['banana', 'cherry', 'date', 'elderberry']);
        });
    });
});