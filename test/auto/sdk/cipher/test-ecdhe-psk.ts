import { Client, Server, PSK_SIZE } from '../../../../src/sdk/cipher/ecdhe-psk';
import { areUint8ArraysEqual } from '../../../../src/sdk/cipher/utility';
import { HandshakeMessage, HandshakeMessageType } from '../../../../src/sdk/cipher/handshake-message';

/**
 * @warning Test code generated by AI.
 */

describe('ECDHE-PSK', () => {
    const psk = new Uint8Array([
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10,
        0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
        0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20
    ]);

    const keyIndex = new Uint8Array([
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10
    ]);

    const additionalElements = new Map<HandshakeMessageType, Uint8Array>();
    additionalElements.set(HandshakeMessageType.PROTOCOL_TYPE, new Uint8Array([0x01, 0x02, 0x03]));

    const getPsk = (keyIndexIn: Uint8Array): Uint8Array => {
        if (!areUint8ArraysEqual(keyIndexIn, keyIndex)) {
            throw new Error("Key index does not match");
        }
        return psk;
    };

    describe('Basic handshake flow', () => {
        test('should complete handshake successfully', () => {
            const client = new Client(psk, keyIndex, additionalElements);
            const server = new Server(getPsk);

            let clientMessage: HandshakeMessage | undefined = undefined;
            let serverMessage: HandshakeMessage | undefined = undefined;

            while (!client.isHandshakeComplete() || !server.isHandshakeComplete()) {
                if (!client.isHandshakeComplete()) {
                    /** Mimic transmission by serializing and parsing */
                    if (serverMessage !== undefined) {
                        const serialized = serverMessage.serialize();
                        serverMessage = new HandshakeMessage(serialized);
                    }
                    clientMessage = client.getNextMessage(serverMessage);
                }

                if (!server.isHandshakeComplete()) {
                    if (clientMessage !== undefined) {
                        const serialized = clientMessage.serialize();
                        clientMessage = new HandshakeMessage(serialized);
                    }
                    serverMessage = server.getNextMessage(clientMessage);
                }
            }

            // Verify handshake completion
            expect(client.isHandshakeComplete()).toBe(true);
            expect(server.isHandshakeComplete()).toBe(true);

            // Verify key agreement
            const clientKeyFromClient = client.getClientKey();
            const serverKeyFromClient = client.getServerKey();
            const clientKeyFromServer = server.getClientKey();
            const serverKeyFromServer = server.getServerKey();

            expect(areUint8ArraysEqual(clientKeyFromClient, clientKeyFromServer)).toBe(true);
            expect(areUint8ArraysEqual(serverKeyFromClient, serverKeyFromServer)).toBe(true);
        });
    });

    describe('Client', () => {
        test('should create client with valid PSK and keyIndex', () => {
            expect(() => {
                new Client(psk, keyIndex, additionalElements);
            }).not.toThrow();
        });

        test('should throw error for invalid additional elements', () => {
            const invalidElements = new Map<HandshakeMessageType, Uint8Array>();
            invalidElements.set(HandshakeMessageType.KEY_INDEX, new Uint8Array([1, 2, 3]));

            expect(() => {
                new Client(psk, keyIndex, invalidElements);
            }).toThrow('Invalid additional element type');
        });

        test('should throw error for invalid additional cipher message elements', () => {
            const invalidElements = new Map<HandshakeMessageType, Uint8Array>();
            invalidElements.set(HandshakeMessageType.CIPHER_MESSAGE, new Uint8Array([1, 2, 3]));

            expect(() => {
                new Client(psk, keyIndex, invalidElements);
            }).toThrow('Invalid additional element type');
        });

        test('should throw error when getting keys before handshake completion', () => {
            const client = new Client(psk, keyIndex, additionalElements);

            expect(() => client.getClientKey()).toThrow();
            expect(() => client.getServerKey()).toThrow();
        });

        test('should throw error when calling getNextMessage with wrong parameters', () => {
            const client = new Client(psk, keyIndex, additionalElements);

            // First call should not accept peer message
            expect(() => {
                const dummyMessage = new HandshakeMessage();
                client.getNextMessage(dummyMessage);
            }).toThrow('Peer message is not expected');
        });

        test('should throw error when exceeding max call count', () => {
            const client = new Client(psk, keyIndex, additionalElements);
            const server = new Server(getPsk);

            // Complete the handshake first
            let clientMessage = client.getNextMessage(); // Call 0 - client first message
            const serverMessage = server.getNextMessage(clientMessage); // Server responds
            clientMessage = client.getNextMessage(serverMessage); // Call 1 - client confirmation
            const serverConfirmation = server.getNextMessage(clientMessage); // Server confirmation
            client.getNextMessage(serverConfirmation); // Call 2 - client receives server confirmation

            // Now try to call getNextMessage again - should throw
            expect(() => {
                client.getNextMessage();
            }).toThrow('Exceeding max call count');
        });
    });

    describe('Server', () => {
        test('should create server with valid getPsk function', () => {
            expect(() => {
                new Server(getPsk);
            }).not.toThrow();
        });

        test('should throw error for invalid PSK length', () => {
            const invalidGetPsk = (keyIndexIn: Uint8Array): Uint8Array => {
                // Validate keyIndex but return wrong PSK size
                if (!areUint8ArraysEqual(keyIndexIn, keyIndex)) {
                    throw new Error("Key index does not match");
                }
                return new Uint8Array(16); // Wrong length
            };

            const client = new Client(psk, keyIndex, additionalElements);
            const server = new Server(invalidGetPsk);

            const clientMessage = client.getNextMessage();

            expect(() => {
                server.getNextMessage(clientMessage);
            }).toThrow(`Invalid PSK length: expected ${PSK_SIZE}, got 16`);
        });

        test('should throw error for unknown key index', () => {
            const unknownKeyGetPsk = (keyIndex: Uint8Array): Uint8Array => {
                // Check keyIndex to avoid unused parameter warning
                if (keyIndex.length > 0) {
                    throw new Error("Unknown key index");
                }
                throw new Error("Unknown key index");
            };

            const client = new Client(psk, keyIndex, additionalElements);
            const server = new Server(unknownKeyGetPsk);

            const clientMessage = client.getNextMessage();

            expect(() => {
                server.getNextMessage(clientMessage);
            }).toThrow("Unknown key index");
        });

        test('should throw error when getting keys before handshake completion', () => {
            const server = new Server(getPsk);

            expect(() => server.getClientKey()).toThrow();
            expect(() => server.getServerKey()).toThrow();
        });

        test('should throw error when calling getNextMessage without peer message', () => {
            const server = new Server(getPsk);

            expect(() => {
                server.getNextMessage();
            }).toThrow('Peer message is required');
        });

        test('should throw error when exceeding max call count', () => {
            const client = new Client(psk, keyIndex, additionalElements);
            const server = new Server(getPsk);

            // Complete the handshake first
            let clientMessage = client.getNextMessage(); // Call 0
            const serverMessage = server.getNextMessage(clientMessage); // Server call 0
            clientMessage = client.getNextMessage(serverMessage); // Call 1
            server.getNextMessage(clientMessage); // Server call 1 - complete server handshake

            // Now try to call getNextMessage again - should throw
            expect(() => {
                const dummyMessage = new HandshakeMessage();
                server.getNextMessage(dummyMessage);
            }).toThrow('Exceeding max call count');
        });
    });

    describe('Message validation', () => {
        test('should handle missing key index in client message', () => {
            const server = new Server(getPsk);
            const invalidMessage = new HandshakeMessage();
            // Missing KEY_INDEX element

            expect(() => {
                server.getNextMessage(invalidMessage);
            }).toThrow('Client message is missing key index');
        });

        test('should handle missing cipher message in client message', () => {
            const server = new Server(getPsk);
            const invalidMessage = new HandshakeMessage();
            invalidMessage.setElement(HandshakeMessageType.KEY_INDEX, keyIndex);
            // Missing CIPHER_MESSAGE element

            expect(() => {
                server.getNextMessage(invalidMessage);
            }).toThrow('Client message is missing cipher message');
        });

        test('should handle invalid cipher message length', () => {
            const server = new Server(getPsk);
            const invalidMessage = new HandshakeMessage();
            invalidMessage.setElement(HandshakeMessageType.KEY_INDEX, keyIndex);
            invalidMessage.setElement(HandshakeMessageType.CIPHER_MESSAGE, new Uint8Array(10)); // Invalid length

            expect(() => {
                server.getNextMessage(invalidMessage);
            }).toThrow('Invalid client message length');
        });
    });

    describe('Multiple handshakes', () => {
        test('should work with different key indices', () => {
            const keyIndex2 = new Uint8Array([
                0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
                0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30
            ]);

            const psk2 = new Uint8Array([
                0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
                0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
                0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
                0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40
            ]);

            const multiGetPsk = (keyIndexIn: Uint8Array): Uint8Array => {
                if (areUint8ArraysEqual(keyIndexIn, keyIndex)) {
                    return psk;
                } else if (areUint8ArraysEqual(keyIndexIn, keyIndex2)) {
                    return psk2;
                }
                throw new Error("Unknown key index");
            };

            // Test first handshake
            const client1 = new Client(psk, keyIndex, additionalElements);
            const server1 = new Server(multiGetPsk);

            let clientMessage1 = client1.getNextMessage();
            const serverMessage1 = server1.getNextMessage(clientMessage1);
            clientMessage1 = client1.getNextMessage(serverMessage1);
            const serverConfirmation1 = server1.getNextMessage(clientMessage1);
            client1.getNextMessage(serverConfirmation1);

            expect(client1.isHandshakeComplete()).toBe(true);
            expect(server1.isHandshakeComplete()).toBe(true);

            // Test second handshake with different key
            const client2 = new Client(psk2, keyIndex2, additionalElements);
            const server2 = new Server(multiGetPsk);

            let clientMessage2 = client2.getNextMessage();
            const serverMessage2 = server2.getNextMessage(clientMessage2);
            clientMessage2 = client2.getNextMessage(serverMessage2);
            const serverConfirmation2 = server2.getNextMessage(clientMessage2);
            client2.getNextMessage(serverConfirmation2);

            expect(client2.isHandshakeComplete()).toBe(true);
            expect(server2.isHandshakeComplete()).toBe(true);

            // Verify different keys were generated
            const keys1Client = client1.getClientKey();
            const keys2Client = client2.getClientKey();
            expect(areUint8ArraysEqual(keys1Client, keys2Client)).toBe(false);
        });
    });
});