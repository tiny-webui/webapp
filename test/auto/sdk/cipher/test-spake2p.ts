import { sodium } from '../../../../src/sdk/cipher/sodium';
import { Client, Server, register, RegistrationResult, W0_SIZE, L_SIZE, SALT_SIZE } from '../../../../src/sdk/cipher/spake2p';
import { HandshakeMessage, HandshakeMessageType } from '../../../../src/sdk/cipher/handshake-message';

/**
 * @warning Test code generated by AI.
 */

describe('SPAKE2+', () => {
    const username = "user";
    const password = "password";
    
    const additionalElements = new Map<HandshakeMessageType, Uint8Array>();
    additionalElements.set(HandshakeMessageType.PROTOCOL_TYPE, new Uint8Array([0x01, 0x02, 0x03]));

    describe('Registration function', () => {
        test('should generate valid registration result', () => {
            const result = register(username, password);
            
            expect(result.w0).toHaveLength(W0_SIZE);
            expect(result.L).toHaveLength(L_SIZE);
            expect(result.salt).toHaveLength(SALT_SIZE);
            expect(result.w0).toBeInstanceOf(Uint8Array);
            expect(result.L).toBeInstanceOf(Uint8Array);
            expect(result.salt).toBeInstanceOf(Uint8Array);
        });

        test('should generate different results for different passwords', () => {
            const result1 = register(username, password);
            const result2 = register(username, "different_password");
            
            expect(sodium.memcmp(result1.w0, result2.w0)).toBe(false);
            expect(sodium.memcmp(result1.L, result2.L)).toBe(false);
            // Salt should be different (randomly generated)
            expect(sodium.memcmp(result1.salt, result2.salt)).toBe(false);
        });

        test('should generate different results for different usernames', () => {
            const result1 = register(username, password);
            const result2 = register("different_user", password);
            
            expect(sodium.memcmp(result1.w0, result2.w0)).toBe(false);
            expect(sodium.memcmp(result1.L, result2.L)).toBe(false);
            // Salt should be different (randomly generated)
            expect(sodium.memcmp(result1.salt, result2.salt)).toBe(false);
        });
    });

    describe('Basic handshake flow', () => {
        test('should complete handshake successfully', () => {
            const registrationResult = register(username, password);
            const client = new Client(username, password, additionalElements);
            const server = new Server((keyIndex: string) => {
                if (keyIndex !== username) {
                    throw new Error("Unknown user");
                }
                return registrationResult;
            });

            let clientMessage: HandshakeMessage | undefined = undefined;
            let serverMessage: HandshakeMessage | undefined = undefined;

            while (!client.isHandshakeComplete() || !server.isHandshakeComplete()) {
                if (!client.isHandshakeComplete()) {
                    // Mimic transmission by serializing and parsing
                    if (serverMessage !== undefined) {
                        const serialized = serverMessage.serialize();
                        serverMessage = new HandshakeMessage(serialized);
                    }
                    clientMessage = client.getNextMessage(serverMessage);
                }

                if (!server.isHandshakeComplete()) {
                    // Mimic transmission by serializing and parsing
                    if (clientMessage !== undefined) {
                        const serialized = clientMessage.serialize();
                        clientMessage = new HandshakeMessage(serialized);
                    }
                    serverMessage = server.getNextMessage(clientMessage);
                }
            }

            // Verify handshake completion
            expect(client.isHandshakeComplete()).toBe(true);
            expect(server.isHandshakeComplete()).toBe(true);

            // Verify key agreement
            const clientKeyFromClient = client.getClientKey();
            const serverKeyFromClient = client.getServerKey();
            const clientKeyFromServer = server.getClientKey();
            const serverKeyFromServer = server.getServerKey();

            expect(sodium.memcmp(clientKeyFromClient, clientKeyFromServer)).toBe(true);
            expect(sodium.memcmp(serverKeyFromClient, serverKeyFromServer)).toBe(true);
        });

        test('should fail with wrong password', () => {
            const registrationResult = register(username, password);
            const client = new Client(username, "wrong_password", additionalElements);
            const server = new Server((keyIndex: string) => {
                if (keyIndex !== username) {
                    throw new Error("Unknown user");
                }
                return registrationResult;
            });

            let clientMessage: HandshakeMessage | undefined = undefined;
            let serverMessage: HandshakeMessage | undefined = undefined;

            // Go through the handshake process
            expect(() => {
                while (!client.isHandshakeComplete() || !server.isHandshakeComplete()) {
                    if (!client.isHandshakeComplete()) {
                        if (serverMessage !== undefined) {
                            const serialized = serverMessage.serialize();
                            serverMessage = new HandshakeMessage(serialized);
                        }
                        clientMessage = client.getNextMessage(serverMessage);
                    }

                    if (!server.isHandshakeComplete()) {
                        if (clientMessage !== undefined) {
                            const serialized = clientMessage.serialize();
                            clientMessage = new HandshakeMessage(serialized);
                        }
                        serverMessage = server.getNextMessage(clientMessage);
                    }
                }
            }).toThrow();
        });

        test('should fail with wrong username', () => {
            const registrationResult = register(username, password);
            const client = new Client("wrong_username", password, additionalElements);
            const server = new Server((keyIndex: string) => {
                if (keyIndex !== username) {
                    throw new Error("Unknown user");
                }
                return registrationResult;
            });

            expect(() => {
                const clientMessage = client.getNextMessage(); // First message with wrong username
                server.getNextMessage(clientMessage); // Server should reject
            }).toThrow("Unknown user");
        });
    });

    describe('Client', () => {
        test('should create client with valid parameters', () => {
            expect(() => {
                new Client(username, password, additionalElements);
            }).not.toThrow();
        });

        test('should throw error for invalid additional elements', () => {
            const invalidElements = new Map<HandshakeMessageType, Uint8Array>();
            invalidElements.set(HandshakeMessageType.KEY_INDEX, new Uint8Array([1, 2, 3]));

            expect(() => {
                new Client(username, password, invalidElements);
            }).toThrow('Invalid additional element type');
        });

        test('should throw error for invalid additional cipher message elements', () => {
            const invalidElements = new Map<HandshakeMessageType, Uint8Array>();
            invalidElements.set(HandshakeMessageType.CIPHER_MESSAGE, new Uint8Array([1, 2, 3]));

            expect(() => {
                new Client(username, password, invalidElements);
            }).toThrow('Invalid additional element type');
        });

        test('should throw error when getting keys before handshake completion', () => {
            const client = new Client(username, password, additionalElements);

            expect(() => client.getClientKey()).toThrow();
            expect(() => client.getServerKey()).toThrow();
        });

        test('should throw error when calling getNextMessage with wrong parameters', () => {
            const client = new Client(username, password, additionalElements);

            // First call should not accept peer message
            expect(() => {
                const dummyMessage = new HandshakeMessage();
                client.getNextMessage(dummyMessage);
            }).toThrow('Unexpected peer message');
        });

        test('should throw error when missing expected peer message', () => {
            const client = new Client(username, password, additionalElements);
            
            // Complete first step
            client.getNextMessage(); // INIT -> RETRIEVE_SALT
            
            // Second call should require peer message
            expect(() => {
                client.getNextMessage(); // Missing peer message
            }).toThrow('Missing peer message');
        });

        test('should clear password after deriving keys', () => {
            const registrationResult = register(username, password);
            const client = new Client(username, password, additionalElements);
            const server = new Server(() => {
                return registrationResult;
            });

            // Go through salt retrieval
            const clientMessage = client.getNextMessage();
            const serverMessage = server.getNextMessage(clientMessage);
            
            // After this step, password should be cleared in client
            client.getNextMessage(serverMessage);
            
            // We can't directly test if password is cleared since it's private,
            // but the fact that handshake continues means key derivation worked
            expect(client).toBeDefined();
        });
    });

    describe('Server', () => {
        test('should create server with valid getUserRegistration function', () => {
            const getUserRegistration = (keyIndex: string): RegistrationResult => {
                return register(keyIndex, password);
            };

            expect(() => {
                new Server(getUserRegistration);
            }).not.toThrow();
        });

        test('should throw error when getting keys before handshake completion', () => {
            const server = new Server(() => register(username, password));

            expect(() => server.getClientKey()).toThrow();
            expect(() => server.getServerKey()).toThrow();
        });

        test('should throw error when first message is missing', () => {
            const server = new Server(() => register(username, password));

            expect(() => {
                server.getNextMessage(); // Missing peer message
            }).toThrow('Missing peer message');
        });

        test('should throw error when key index is missing', () => {
            const server = new Server(() => register(username, password));
            const emptyMessage = new HandshakeMessage();

            expect(() => {
                server.getNextMessage(emptyMessage);
            }).toThrow('Missing key index');
        });

        test('should handle getUserRegistration throwing error', () => {
            const server = new Server((keyIndex: string) => {
                throw new Error(`User ${keyIndex} not found`);
            });

            const client = new Client(username, password, additionalElements);
            const clientMessage = client.getNextMessage();

            expect(() => {
                server.getNextMessage(clientMessage);
            }).toThrow('User user not found');
        });
    });

    describe('Message validation', () => {
        test('should validate salt message length', () => {
            const registrationResult = register(username, password);
            const client = new Client(username, password, additionalElements);
            const server = new Server(() => registrationResult);

            const clientMessage = client.getNextMessage();
            server.getNextMessage(clientMessage);

            // Corrupt the server message with wrong salt length
            const corruptedMessage = new HandshakeMessage();
            corruptedMessage.setElement(HandshakeMessageType.CIPHER_MESSAGE, new Uint8Array(15)); // Wrong length

            expect(() => {
                client.getNextMessage(corruptedMessage);
            }).toThrow('Invalid server message length');
        });

        test('should validate share point message length', () => {
            const registrationResult = register(username, password);
            const client = new Client(username, password, additionalElements);
            const server = new Server(() => registrationResult);

            // Complete first two steps
            const clientMessage = client.getNextMessage();
            const serverMessage = server.getNextMessage(clientMessage);
            client.getNextMessage(serverMessage);

            // Corrupt the client message with wrong point length
            const corruptedMessage = new HandshakeMessage();
            corruptedMessage.setElement(HandshakeMessageType.CIPHER_MESSAGE, new Uint8Array(16)); // Wrong length

            expect(() => {
                server.getNextMessage(corruptedMessage);
            }).toThrow('Invalid client message length');
        });

        test('should validate confirm message authentication', () => {
            const registrationResult = register(username, password);
            const client1 = new Client(username, password, additionalElements);
            const client2 = new Client(username, "different_password", additionalElements);
            const server = new Server(() => registrationResult);

            // Use client1 for first steps
            let clientMessage = client1.getNextMessage();
            let serverMessage = server.getNextMessage(clientMessage);
            clientMessage = client1.getNextMessage(serverMessage);
            serverMessage = server.getNextMessage(clientMessage);

            // Try to use client2 (wrong password) for final confirmation
            // This should fail during decryption/validation
            expect(() => {
                client2.getNextMessage(serverMessage);
            }).toThrow();
        });
    });

    describe('Edge cases', () => {
        test('should handle empty username', () => {
            expect(() => {
                register("", password);
            }).not.toThrow();
        });

        test('should handle empty password', () => {
            expect(() => {
                register(username, "");
            }).not.toThrow();
        });

        test('should handle long username and password', () => {
            const longUsername = "a".repeat(1000);
            const longPassword = "b".repeat(1000);
            
            expect(() => {
                register(longUsername, longPassword);
            }).not.toThrow();
        });

        test('should handle unicode characters in credentials', () => {
            const unicodeUsername = "用户名";
            const unicodePassword = "密码123!@#";
            
            expect(() => {
                register(unicodeUsername, unicodePassword);
            }).not.toThrow();
        });
    });

    describe('Multiple handshake sessions', () => {
        test('should support multiple concurrent clients with same credentials', () => {
            const registrationResult = register(username, password);
            const client1 = new Client(username, password, additionalElements);
            const client2 = new Client(username, password, additionalElements);
            const server1 = new Server(() => registrationResult);
            const server2 = new Server(() => registrationResult);

            // Run two independent handshakes
            const runHandshake = (client: Client, server: Server) => {
                let clientMessage: HandshakeMessage | undefined = undefined;
                let serverMessage: HandshakeMessage | undefined = undefined;

                while (!client.isHandshakeComplete() || !server.isHandshakeComplete()) {
                    if (!client.isHandshakeComplete()) {
                        if (serverMessage !== undefined) {
                            const serialized = serverMessage.serialize();
                            serverMessage = new HandshakeMessage(serialized);
                        }
                        clientMessage = client.getNextMessage(serverMessage);
                    }

                    if (!server.isHandshakeComplete()) {
                        if (clientMessage !== undefined) {
                            const serialized = clientMessage.serialize();
                            clientMessage = new HandshakeMessage(serialized);
                        }
                        serverMessage = server.getNextMessage(clientMessage);
                    }
                }

                return {
                    clientKey: client.getClientKey(),
                    serverKey: client.getServerKey()
                };
            };

            const session1 = runHandshake(client1, server1);
            const session2 = runHandshake(client2, server2);

            // Keys should be different for different sessions (due to random nonces)
            expect(sodium.memcmp(session1.clientKey, session2.clientKey)).toBe(false);
            expect(sodium.memcmp(session1.serverKey, session2.serverKey)).toBe(false);
        });
    });
});