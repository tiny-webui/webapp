import { sodium } from '../../src/sdk/cipher/sodium';
import { Encryptor, Decryptor, KEY_SIZE, NONCE_SIZE, TAG_SIZE } from '../../src/sdk/cipher/chacha20-poly1305';

/**
 * @warning Tests generated by AI.
 */

describe('ChaCha20-Poly1305 Cipher', () => {
    let key: Uint8Array;
    let plaintext: Uint8Array;

    beforeAll(() => {
    });

    beforeEach(() => {
        // Generate a random key for each test
        key = sodium.randombytes_buf(KEY_SIZE);
        plaintext = new TextEncoder().encode('Hello, World! This is a test message.');
    });

    describe('Constants', () => {
        it('should have correct constant values', () => {
            expect(KEY_SIZE).toBe(32);
            expect(NONCE_SIZE).toBe(12);
            expect(TAG_SIZE).toBe(16);
        });
    });

    describe('Encryptor', () => {
        let encryptor: Encryptor;

        beforeEach(() => {
            encryptor = new Encryptor(key);
        });

        it('should create an encryptor with a valid key', () => {
            expect(encryptor).toBeInstanceOf(Encryptor);
        });

        it('should encrypt plaintext successfully', () => {
            const ciphertext = encryptor.encrypt(plaintext);
            
            expect(ciphertext).toBeInstanceOf(Uint8Array);
            expect(ciphertext.length).toBe(NONCE_SIZE + plaintext.length + TAG_SIZE);
        });

        it('should produce different ciphertext for the same plaintext', () => {
            const ciphertext1 = encryptor.encrypt(plaintext);
            const ciphertext2 = encryptor.encrypt(plaintext);
            
            expect(ciphertext1).not.toEqual(ciphertext2);
        });

        it('should increment nonce for each encryption', () => {
            const ciphertext1 = encryptor.encrypt(plaintext);
            const ciphertext2 = encryptor.encrypt(plaintext);
            
            // Extract nonces
            const nonce1 = ciphertext1.slice(0, NONCE_SIZE);
            const nonce2 = ciphertext2.slice(0, NONCE_SIZE);
            
            // Convert to numbers for comparison (assuming little-endian)
            const toNumber = (bytes: Uint8Array) => {
                let result = 0;
                for (let i = 0; i < Math.min(8, bytes.length); i++) {
                    result += bytes[i] * Math.pow(256, i);
                }
                return result;
            };
            
            expect(toNumber(nonce2)).toBeGreaterThan(toNumber(nonce1));
        });

        it('should handle empty plaintext', () => {
            const emptyPlaintext = new Uint8Array(0);
            const ciphertext = encryptor.encrypt(emptyPlaintext);
            
            expect(ciphertext.length).toBe(NONCE_SIZE + TAG_SIZE);
        });

        it('should handle large plaintext', () => {
            const largePlaintext = new Uint8Array(10000).fill(65); // 10KB of 'A's
            const ciphertext = encryptor.encrypt(largePlaintext);
            
            expect(ciphertext.length).toBe(NONCE_SIZE + largePlaintext.length + TAG_SIZE);
        });
    });

    describe('Decryptor', () => {
        let decryptor: Decryptor;

        beforeEach(() => {
            decryptor = new Decryptor(key);
        });

        it('should create a decryptor with a valid key', () => {
            expect(decryptor).toBeInstanceOf(Decryptor);
        });

        it('should throw error for too short ciphertext', () => {
            const shortCiphertext = new Uint8Array(NONCE_SIZE + TAG_SIZE - 1);
            
            expect(() => {
                decryptor.decrypt(shortCiphertext);
            }).toThrow('Cipher text too short');
        });

        it('should throw error for replay attack (same nonce)', () => {
            const encryptor = new Encryptor(key);
            const ciphertext = encryptor.encrypt(plaintext);
            
            // First decryption should work
            const decrypted1 = decryptor.decrypt(ciphertext);
            expect(decrypted1).toEqual(plaintext);
            
            // Second decryption with same ciphertext should fail
            expect(() => {
                decryptor.decrypt(ciphertext);
            }).toThrow('Replay message detected');
        });

        it('should throw error for out-of-order messages', () => {
            const encryptor = new Encryptor(key);
            const ciphertext1 = encryptor.encrypt(plaintext);
            const ciphertext2 = encryptor.encrypt(plaintext);
            
            // Decrypt message 2 first
            decryptor.decrypt(ciphertext2);
            
            // Then trying to decrypt message 1 should fail
            expect(() => {
                decryptor.decrypt(ciphertext1);
            }).toThrow('Replay message detected');
        });

        it('should handle invalid authentication tag', () => {
            const encryptor = new Encryptor(key);
            const ciphertext = encryptor.encrypt(plaintext);
            
            // Corrupt the last byte (part of the authentication tag)
            ciphertext[ciphertext.length - 1] ^= 1;
            
            expect(() => {
                decryptor.decrypt(ciphertext);
            }).toThrow();
        });

        it('should handle corrupted nonce', () => {
            const encryptor = new Encryptor(key);
            const ciphertext = encryptor.encrypt(plaintext);
            
            // Corrupt the first byte (part of the nonce)
            ciphertext[0] ^= 1;
            
            expect(() => {
                decryptor.decrypt(ciphertext);
            }).toThrow();
        });
    });

    describe('Encrypt-Decrypt Round Trip', () => {
        it('should decrypt encrypted data correctly', () => {
            const encryptor = new Encryptor(key);
            const decryptor = new Decryptor(key);
            
            const ciphertext = encryptor.encrypt(plaintext);
            const decrypted = decryptor.decrypt(ciphertext);
            
            expect(decrypted).toEqual(plaintext);
        });

        it('should handle multiple sequential encryptions and decryptions', () => {
            const encryptor = new Encryptor(key);
            const decryptor = new Decryptor(key);
            
            const messages = [
                new TextEncoder().encode('First message'),
                new TextEncoder().encode('Second message'),
                new TextEncoder().encode('Third message'),
            ];
            
            const ciphertexts = messages.map(msg => encryptor.encrypt(msg));
            const decrypted = ciphertexts.map(ct => decryptor.decrypt(ct));
            
            decrypted.forEach((decMsg, index) => {
                expect(decMsg).toEqual(messages[index]);
            });
        });

        it('should handle empty message encryption/decryption', () => {
            const encryptor = new Encryptor(key);
            const decryptor = new Decryptor(key);
            
            const emptyMessage = new Uint8Array(0);
            const ciphertext = encryptor.encrypt(emptyMessage);
            const decrypted = decryptor.decrypt(ciphertext);
            
            expect(decrypted).toEqual(emptyMessage);
        });

        it('should work with different key pairs (isolation test)', () => {
            const key1 = sodium.randombytes_buf(KEY_SIZE);
            const key2 = sodium.randombytes_buf(KEY_SIZE);
            
            const encryptor1 = new Encryptor(key1);
            const decryptor1 = new Decryptor(key1);
            const decryptor2 = new Decryptor(key2);
            
            const ciphertext = encryptor1.encrypt(plaintext);
            
            // Should decrypt correctly with matching key
            const decrypted1 = decryptor1.decrypt(ciphertext);
            expect(decrypted1).toEqual(plaintext);
            
            // Should fail with wrong key
            expect(() => {
                decryptor2.decrypt(ciphertext);
            }).toThrow();
        });
    });

    describe('Edge Cases', () => {
        it('should handle maximum safe counter value', () => {
            const encryptor = new Encryptor(key);
            
            // This test ensures we don't hit counter overflow too early
            // We'll encrypt a few messages to make sure counter increments work
            for (let i = 0; i < 5; i++) {
                const ciphertext = encryptor.encrypt(plaintext);
                expect(ciphertext).toBeInstanceOf(Uint8Array);
            }
        });

        it('should maintain state between encryptions', () => {
            const encryptor = new Encryptor(key);
            const decryptor = new Decryptor(key);
            
            // Encrypt several messages
            const message1 = new TextEncoder().encode('Message 1');
            const message2 = new TextEncoder().encode('Message 2');
            
            const cipher1 = encryptor.encrypt(message1);
            const cipher2 = encryptor.encrypt(message2);
            
            // Should be able to decrypt in order
            const decrypted1 = decryptor.decrypt(cipher1);
            const decrypted2 = decryptor.decrypt(cipher2);
            
            expect(decrypted1).toEqual(message1);
            expect(decrypted2).toEqual(message2);
        });

        it('should handle binary data', () => {
            const encryptor = new Encryptor(key);
            const decryptor = new Decryptor(key);
            
            // Create binary data with all possible byte values
            const binaryData = new Uint8Array(256);
            for (let i = 0; i < 256; i++) {
                binaryData[i] = i;
            }
            
            const ciphertext = encryptor.encrypt(binaryData);
            const decrypted = decryptor.decrypt(ciphertext);
            
            expect(decrypted).toEqual(binaryData);
        });
    });
});
